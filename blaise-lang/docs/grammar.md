# BLAISE Grammar

```perl
ENTRY_POINT := PROGRAM | MODULE

PROGRAM := 'program' IDENTIFIER ';' VARIABLES_CLAUSES?  '.' COMPOUND_STATEMENT
MODULE := # WORK IN PROGRESS

IDENTIFIER := /[a-zA-z][a-zA-z0-9_]*/
NUMBER := /[+-]?[0-9]+(\\.[0-9]+)/ 

VARIABLES_CLAUSES := 'var' VARIABLE_CLAUSE*
VARIABLE_CLAUSE :=  VARIABLE_NAME_LIST ':' VARIABLE_TYPE ';'
VARIABLE_NAME_LIST := IDENTIFIER (',' IDENTIFIER)*
VARIABLE_TYPE := ('unsigned'? 'byte')|('unsigned'? 'integer')|('unsigned'? 'long')|
                 'char'|'string'|
                 'float'|'double'|
                 'boolean'

COMPOUND_STATEMENT := 'begin' STATEMENT* 'end'
STATEMENT => (COMPOUND_STATEMENT | FUNCTION_CALL | ASSIGNMENT) ';' # WORK IN PROGRESS

FUNCTION_CALL := IDENTIFIER '(' FUNCTION_CALL_PARAMTERS? ')'
FUNCTION_CALL_PARAMTERS := EXPRESSION (',' EXPRESSION)*

ASSIGNMENT = IDENTIFIER ':=' EXPRESSION

# Expression idea from https://en.wikipedia.org/wiki/Operator-precedence_parser
# but I added a few more levels and operator
EXPRESSION := OR_EXPRESSION
OR_EXPRESSION := AND_EXPRESSION ( 'eager'? 'or' AND_EXPRESSION)*
AND_EXPRESSION := EQUALITY_EXPRESSION ( 'eager'? 'and' EQUALITY_EXPRESSION)*
EQUALITY_EXPRESSION := INEQUALITY_EXPRESSION (('==' | '<>' ) INEQUALITY_EXPRESSION)*
INEQUALITY_EXPRESSION := ADDITIVE_EXPRESSION (('<' | '<=' | '>=' | '>') ADDITIVE_EXPRESSION )*
ADDITIVE_EXPRESSION := MULTIPLICATIVE_EXPRESSION (('+' | '-' ) MULTIPLICATIVE_EXPRESSION )*
MULTIPLICATIVE_EXPRESSION := EXPRESSION_TERM (('*' | '/' | '%' ) EXPRESSION_TERM)*
EXPRESSION_TERM := '(' EXPRESSION ')' | NUMBER | IDENTIFIER | FUNCTION_CALL | '-' EXPRESSION_TERM | 'not' EXPRESSION
```
